<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="format-detection" content="telephone=no">
    <title>Ravyn | Tsai Cho Lin Portfolio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <style>
        @font-face {
            font-family: "ARP";
            src: url("ARP-150.ttf");
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            /* Disable selection and dragging to protect content */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -webkit-user-drag: none;
        }

        html,
        body {
            cursor: url('./todo.png') 0 0, auto !important;
        }

        body {
            background-color: #0e0e0e;
            color: #fff;
            font-family: "Helvetica Neue", Arial, "Noto Sans TC", sans-serif;
            overflow-x: hidden;
            width: 100%;
            line-height: 1.6;
            /* Recalibrated: 16px @ 1920px ~= 0.83vw */
            font-size: 0.83vw;
        }

        /* Ensure links and interactive elements also use the custom cursor */
        a,
        .nav-link,
        .project-item,
        .grad-item,
        .back-book,
        .close-book,
        .close-btn,
        .nav-arrow,
        button,
        [onclick] {
            cursor: url('./todo.png') 0 0, pointer !important;
        }

        /* Prevent phone numbers from being styled as links on mobile */
        [href^="tel:"],
        a[href^="tel:"] {
            color: inherit !important;
            text-decoration: none !important;
        }

        /* --- 導覽列 --- */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            /* 40px @ 1920 ~= 2.1vw */
            padding: 2.1vw 5%;
            display: flex;
            justify-content: flex-end;
            z-index: 100;
        }

        .nav-link {
            color: #fff;
            text-decoration: none;
            /* 0.8rem (12.8px) -> 0.67vw */
            font-size: 0.7vw;
            letter-spacing: 0.2vw;
            cursor: pointer;
            font-weight: 300;
            transition: 0.3s;
        }

        .nav-link:hover {
            opacity: 0.5;
        }

        /* --- 封面 --- */
        .hero {
            height: 100vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        .slideshow-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0;
            filter: brightness(0.3) grayscale(0.8);
        }

        .hero-bg-slider {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
        }

        .hero-bg-slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: 1.5s;
            image-orientation: from-image;
        }

        .hero-bg-slide.active {
            opacity: 1;
        }

        .hero-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: -1;
        }

        .hero h1 {
            font-family: "ARP", sans-serif;
            font-size: 9vw;
            letter-spacing: -0.2vw;
            font-weight: 900;
            z-index: 20;
            /* High z-index */
            filter: url(#wave-filter);
            text-align: center;
            pointer-events: none;
            line-height: 1;
            position: relative;
        }

        .hero h2 {
            font-size: 1.1vw;
            letter-spacing: 0.8vw;
            color: #777;
            text-transform: uppercase;
            margin-top: 0.5vw;
            z-index: 20;
            /* Match H1 */
            position: relative;
        }

        /* --- 作品列表 --- */
        .project-section {
            padding-top: 10vh;
        }

        .project-item {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            width: 100%;
            padding: 5vh 10%;
            /* 80px @ 1920 ~= 4.2vw */
            gap: 4.2vw;
            opacity: 0.1;
            transform: scale(0.65);
            cursor: pointer;
            transition: 0.5s;
        }

        .project-item:nth-child(even) {
            flex-direction: row-reverse;
        }

        .project-image-box {
            flex: 1.3;
            width: 100%;
            height: 60vh;
            /* Restore vh for height stability */
            overflow: hidden;
            background: #111;
        }

        .project-image-box img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: grayscale(1);
            transition: 1.2s;
        }

        .project-item:hover .project-image-box img {
            filter: grayscale(0);
            transform: scale(1.03);
        }

        .project-content {
            flex: 0.7;
            width: 100%;
        }

        .project-content span {
            /* 0.7rem (~11px) -> 0.6vw */
            font-size: 0.6vw;
            color: #aaa;
            letter-spacing: 0.2vw;
            display: block;
            margin-bottom: 0.8vw;
        }

        .project-content h3 {
            /* 2.5rem (40px) -> 2.1vw */
            font-size: 2.1vw;
            font-weight: 700;
            line-height: 1.2;
            margin-bottom: 1.3vw;
        }

        .project-content p {
            /* 1rem (16px) -> 0.83vw */
            font-size: 0.85vw;
            font-weight: 300;
            color: #ccc;
        }

        /* --- 左右翻頁瀏覽器 --- */
        #book-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 4000;
            display: none;
            opacity: 0;
            transition: 0.3s;
            /* Speed up from 0.5s to 0.3s */
        }

        #book-overlay.active {
            opacity: 1;
        }

        #image-viewer {
            width: 100%;
            height: 100%;
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
            scroll-snap-type: x mandatory;
            -webkit-scroll-snap-type: x mandatory;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scroll-padding: 0;
            background-color: #000;
        }

        .img-slide {
            width: 100vw;
            flex-shrink: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            scroll-snap-align: center;
            overflow-x: scroll;
            /* Enable horizontal swipe */
            overflow-y: hidden;
            /* contain: layout; REMOVED */

            background-color: #000;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
            -webkit-transform: translate3d(0, 0, 0);
        }

        #image-viewer img {
            max-width: 85vw;
            max-height: 90vh;
            object-fit: contain;
            opacity: 1;
            /* Enhance clarity for scaled images */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: auto;
            /* transform: translateZ(0); REMOVED to allow high-res re-rasterization */
            /* Force GPU rendering for sharper edges */
            transition: 0.3s;
        }

        /* --- 併排模式 (Spread Mode) --- */
        .spread-mode .img-slide {
            gap: 0;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            contain: layout;
            /* Helps browser optimize rendering of individual slides */
        }

        .zoom-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center center;
            cursor: grab;
            user-select: none;

            will-change: auto;
            transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1);
        }

        .zoom-wrapper.dragging {
            cursor: grabbing;
            transition: none;
        }

        .spread-mode .img-slide img {
            max-width: 49vw;
            height: auto;
            max-height: 95vh;
            pointer-events: none;
            /* Prevents dragging the image itself */
        }

        /* Specifically for the cover (first slide) in spread mode */
        .spread-mode .img-slide:first-child img {
            max-width: 80vw;
            max-height: 95vh;
        }

        @media (max-width: 768px) {
            .spread-mode .img-slide {
                flex-direction: column;
                /* Mobile stay vertical or stack */
                gap: 2vh;
            }

            .spread-mode .img-slide img {
                max-width: 85vw;
                max-height: 40vh;
            }
        }

        /* --- Vertical Stack Mode --- */
        .vertical-mode .img-slide {
            align-items: center;
        }

        .vertical-mode .zoom-wrapper {
            flex-direction: column;
            justify-content: center;
            height: 100%;
            width: 100%;
        }

        #image-viewer.vertical-mode .img-slide img {
            max-width: 90vw;
            max-height: 48vh;
            margin: 0.5vh 0;
            object-fit: contain;
        }

        .back-book {
            position: fixed;
            top: 40px;
            left: 40px;
            font-size: 0.9vw;
            color: #fff;
            cursor: pointer;
            z-index: 4001;
            letter-spacing: 2px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            transition: 0.3s;
            display: none;
            /* Hidden by default */
        }

        .back-book:hover {
            background: #fff;
            color: #000;
        }

        .nav-arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            padding: 1.3vw 0.8vw;
            cursor: pointer;
            font-size: 1.5vw;
            z-index: 5500;
            transition: 0.3s;
            border-radius: 4px;
            user-select: none;
        }

        .nav-arrow:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .prev-arrow {
            left: 2%;
        }

        .next-arrow {
            right: 2%;
        }

        .close-book,
        .close-btn {
            position: fixed;
            top: 3vw;
            /* Default for desktop */
            right: 5%;
            color: #fff;
            cursor: pointer;
            letter-spacing: 0.2vw;
            /* Ensure readable size on all devices: min 14px */
            font-size: clamp(14px, 0.7vw, 16px);
            z-index: 6000;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5vw 1vw;
            border-radius: 4px;
            font-family: sans-serif;
            /* Setup safe font for 'X' icon */
        }

        /* --- 加載器 (Loader) --- */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0e0e0e;
            z-index: 2147483647;
            /* Ensure it's above everything */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease;
        }

        .loader-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .building-svg {
            width: 150px;
            margin-bottom: 20px;
        }

        .loading-text {
            font-family: "ARP", sans-serif;
            letter-spacing: 5px;
            font-size: 10px;
            color: #555;
        }

        #percent {
            color: #fff;
        }

        #arch-line {
            stroke-dasharray: 320;
            stroke-dashoffset: 320;
        }

        /* --- 關於我 --- */
        #about-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            z-index: 3000;
            display: none;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
        }

        .about-content {
            width: 90%;
            max-width: 80vw;
            display: flex;
            align-items: flex-start;
            /* 80px -> 4.2vw */
            gap: 4.2vw;
            padding: 10vh 0;
        }

        .about-photo {
            flex: 0.7;
            width: 25vw;
            aspect-ratio: 3/4;
            background: #151515;
            overflow: hidden;
            position: sticky;
            top: 10vh;
        }

        .about-photo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .about-text {
            flex: 1.3;
            display: flex;
            flex-direction: column;
            text-align: left;
        }

        .about-header {
            margin-bottom: 2vw;
            border-bottom: 1px solid #333;
            padding-bottom: 1.3vw;
        }

        .about-header h2 {
            /* 2.8rem (~45px) -> 2.35vw */
            font-size: 2.35vw;
            font-weight: 700;
            color: #fff;
        }

        .about-header h2 span {
            /* 1.3rem (~21px) -> 1.1vw */
            font-size: 1.1vw;
            color: #888;
            font-weight: 300;
            margin-left: 0.8vw;
            display: inline-block;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5vw;
        }

        .info-item h4 {
            /* 1.1rem (~17.6px) -> 0.92vw */
            font-size: 0.95vw;
            color: #bdcde6;
            letter-spacing: 0.3vw;
            margin-bottom: 0.5vw;
            font-weight: 600;
            border-left: 3px solid #bdcde6;
            padding-left: 0.8vw;
        }

        .info-item p,
        .info-item li {
            /* 0.95rem (~15.2px) -> 0.8vw */
            font-size: 0.8vw;
            color: #ccc;
            list-style: none;
            font-weight: 300;
            line-height: 1.8;
        }

        .info-item ul li {
            margin-bottom: 0.4vw;
            position: relative;
            padding-left: 1.2vw;
        }

        .info-item ul li::before {
            content: "○";
            position: absolute;
            left: 0;
            color: #555;
        }

        /* --- Graduation Menu Global Styles --- */
        #grad-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Background removed; handled by slider */
            background: #000;
            z-index: 2147483647 !important;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .grad-bg-slider {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            pointer-events: none;
        }

        .grad-bg-slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
            image-orientation: from-image;
        }

        .grad-bg-slide.active {
            opacity: 1;
        }

        .grad-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            /* Dark overlay for text readability */
            z-index: -1;
            pointer-events: none;
        }

        #grad-menu.active {
            opacity: 1;
        }

        .grad-title {
            font-family: "ARP", sans-serif;
            font-size: 3vw;
            color: #fff;
            margin-bottom: 5vh;
            letter-spacing: 5px;
        }

        .grad-options {
            display: flex;
            gap: 2vw;
            width: 80%;
            justify-content: center;
        }

        .grad-item {
            flex: 1;
            height: 40vh;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: 0.3s;
            background: rgba(255, 255, 255, 0.02);
            position: relative;
            overflow: hidden;
        }

        .grad-item h4 {
            font-family: "Helvetica Neue", sans-serif;
            font-size: 1.2vw;
            font-weight: 300;
            letter-spacing: 2px;
            color: #fff;
            transition: 0.3s;
            text-align: center;
            line-height: 1.5;
        }

        /* Fix: Only enable hover effects on devices that support hover (Mouse) */
        @media (hover: hover) {
            .grad-item:hover {
                transform: translateY(-10px);
                border-color: rgba(255, 255, 255, 0.8);
            }

            .item-book:hover {
                background: url('midle.webp') center/cover no-repeat;
            }

            .item-model:hover {
                background: url('modelmenu.webp') center/cover no-repeat;
            }

            .item-proposal:hover {
                background: url('proposal.webp') center/cover no-repeat;
            }

            .item-design:hover {
                background: url('designmenu.jpg') center/cover no-repeat;
            }

            .grad-item:hover h4 {
                color: #fff;
                font-weight: 500;
                text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            }
        }

        .grad-close {
            position: absolute;
            top: 40px;
            right: 5%;
            color: #777;
            cursor: pointer;
            font-size: 0.9vw;
            letter-spacing: 2px;
            transition: 0.3s;
        }

        .grad-close:hover {
            color: #fff;
        }

        /* --- 3D 旋轉畫廊 (3D Rotating Gallery) --- */
        #gallery-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            z-index: 4000;
            opacity: 0;
            transition: opacity 0.8s ease;
            perspective: 1000px;
            /* Enable 3D Space */
            overflow: hidden;
            pointer-events: auto;
            /* Catch drags */
        }

        /* ... skipped ... */

        .gallery-item {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-box-reflect: below 10px linear-gradient(transparent 60%, rgba(0, 0, 0, 0.4));
            cursor: pointer;
            transition: 0.3s;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background: #000;
            pointer-events: auto;
            will-change: transform;
        }

        @media (max-width: 768px) {
            .gallery-item {
                -webkit-box-reflect: none;
                /* Disable expensive reflection on mobile */
            }
        }

        #gallery-overlay.active {
            opacity: 1;
        }

        #gallery-stage {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transform-style: preserve-3d;
            touch-action: none;
            /* Critical for mobile drag */
            pointer-events: none;
            /* Let clicks pass through to items behind Z=0 */
        }

        #gallery-spinner {
            position: relative;
            width: 250px;
            height: 350px;
            transform-style: preserve-3d;
            transition: transform 0.1s ease-out;
            pointer-events: none;
            will-change: transform;
        }

        /* 為了讓旋轉更順滑, 滑動結束後加慣性動畫 */
        #gallery-spinner.inertia {
            transition: transform 1s cubic-bezier(0.2, 0, 0.2, 1);
        }



        .gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .gallery-item:hover {
            border-color: #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        /* --- Lightbox Styles (Restored & Enhanced) --- */
        #collage-lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 5000;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.4s ease;
            /* Allow click-through to close on background */
            cursor: pointer;
        }

        #collage-lightbox.active {
            opacity: 1;
        }

        #collage-lightbox img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            transform: scale(0.9);
            transition: transform 0.4s cubic-bezier(0.2, 0, 0.2, 1);
            cursor: zoom-in;
            /* Indicate zoomable */
        }

        #collage-lightbox.active img {
            transform: scale(1);
        }

        /* Zoomed State */
        #collage-lightbox img.zoomed {
            transform: scale(1.8) !important;
            max-width: none !important;
            max-height: none !important;
            cursor: zoom-out !important;
            /* Ensure it covers screen if needed */
            min-width: 50vw;
        }

        /* Mobile Adjustments for Gallery */
        @media (max-width: 768px) {
            #gallery-spinner {
                width: 160px;
                height: 220px;
            }
        }

        /* Correctly re-wrap all these mobile overrides */
        @media (max-width: 768px) {
            body {
                font-size: 3vw;
            }

            nav {
                padding: 30px 5%;
            }

            .nav-link {
                font-size: 14px;
                letter-spacing: 2px;
            }

            /* Restore About Me Close Button to normal */
            .close-btn {
                font-size: 12px !important;
                /* Smaller text */
                padding: 5px 10px !important;
                /* Minimal padding */
                top: 20px !important;
                background: transparent !important;
                border: none !important;
                z-index: 6000 !important;
            }

            /* Keep Portfolio Close Button visible but sized reasonably */
            .close-book {
                font-size: 14px !important;
                padding: 8px 16px !important;
                top: 20px !important;
                background: rgba(0, 0, 0, 0.8) !important;
                border: 1px solid white !important;
                z-index: 2147483647 !important;
            }

            .back-book {
                font-size: 14px !important;
                padding: 8px 16px !important;
                top: 20px !important;
                left: 20px !important;
                /* Left aligned */
                background: rgba(0, 0, 0, 0.8) !important;
                border: 1px solid white !important;
                z-index: 2147483647 !important;
            }

            /* --- Graduation Menu Mobile Overrides --- */
            /* Base styles moved to global scope */
            .grad-title {
                font-size: 5.5vw;
                margin-bottom: 4vh;
                white-space: nowrap;
                /* Prevent wrapping */
                letter-spacing: 3px;
                /* Slightly reduced letter spacing */
            }

            .grad-options {
                flex-direction: column;
                gap: 2vh;
                width: 85%;
            }

            .grad-item {
                width: 100%;
                height: 12vh;
                /* Compact for mobile */
            }

            .grad-item h4 {
                font-size: 4vw;
            }

            .grad-close {
                font-size: 14px;
                padding: 10px 20px;
                top: 20px;
            }

            /* Force images to be visible on mobile */
            #image-viewer img {
                opacity: 1 !important;
                display: block !important;
                min-width: 100vw !important;
                /* Force full width */
                height: auto !important;
                max-height: 80vh !important;
                object-fit: contain !important;
            }

            .hero h1 {
                /* Reduced from 13vw to 11vw per user request */
                font-size: 11vw;
            }

            .hero h2 {
                /* Reduced from 3.5vw to 2.8vw */
                font-size: 2.8vw;
                letter-spacing: 5px;
            }

            .about-content {
                flex-direction: column;
                align-items: center;
                /* Fit to screen height */
                height: 100vh;
                justify-content: flex-start;
                /* Align to top to respect padding */
                gap: 1.5vh;
                /* Reduced gap to save space */
                padding-top: 6vh;
                /* Reduced padding from 12vh */
                max-width: 90vw;
                overflow: hidden;
                /* Prevent scrolling */
            }

            .about-photo {
                position: relative;
                top: 0;
                margin: 0;
                /* Increased width to show full shoulders, constrained height to crop top/bottom */
                width: 28vh;
                height: 16vh;
                flex-shrink: 0;
            }

            /* Fix photo framing */
            .about-photo img {
                object-position: center 40%;
                /* Relaxed slightly from 50% */
            }

            .about-text {
                /* Ensure text container fits remaining space */
                height: auto;
                justify-content: center;
            }

            .about-header {
                margin-bottom: 1.5vh;
                padding-bottom: 1vh;
            }

            .about-header h2 {
                /* Use vh for vertical fit */
                font-size: 3vh;
            }

            .about-header h2 span {
                font-size: 1.8vh;
                margin-top: 0.5vh;
            }

            .info-grid {
                gap: 1.5vh;
            }

            .info-item h4 {
                font-size: 1.8vh;
                letter-spacing: 2px;
                margin-bottom: 0.5vh;
            }

            .info-item p,
            .info-item li {
                font-size: 1.4vh;
                line-height: 1.4;
            }

            .info-item ul li {
                margin-bottom: 0.2vh;
            }

            .nav-arrow {
                display: none;
            }

            .project-item,
            .project-item:nth-child(even) {
                flex-direction: column;
                height: auto;
                min-height: auto;
                padding: 10vh 5%;
                gap: 4vh;
                /* Initial state for mobile animation (match desktop feel) */
                opacity: 0.2;
                transform: scale(0.9);
            }

            .project-image-box {
                height: 40vh;
                max-height: none;
                flex: none;
            }

            /* Critical Fix: specific disable of hover grayscale on mobile */
            .project-image-box img {
                filter: grayscale(0) !important;
                /* Always colored, GSAP handles opacity */
                transform: scale(1) !important;
                /* Disable hover zoom effect on mobile if present */
            }

            .project-content {
                flex: none;
                width: 100%;
                max-width: none;
                text-align: left;
            }

            .project-content h3 {
                font-size: 8vw;
            }

            .project-content span {
                font-size: 3vw;
                letter-spacing: 2px;
            }

            .project-content p {
                font-size: 4vw;
            }
        }

        footer {
            padding: 60px 0;
            text-align: center;
            color: #333;
            font-size: 0.65rem;
            letter-spacing: 3px;
        }

        .svg-filters {
            position: absolute;
            visibility: hidden;
            width: 0;
            height: 0;
        }
    </style>
</head>

<body>
    <div id="loader">
        <div class="loader-content">
            <svg viewBox="0 0 100 100" class="building-svg">
                <path id="arch-line" d="M10 90 L10 10 L90 10 L90 90 Z" fill="none" stroke="white" stroke-width="0.5" />
            </svg>
            <div class="loading-text">CONSTRUCTING... <span id="percent">0</span>%</div>
        </div>
    </div>

    <svg class="svg-filters">
        <filter id="wave-filter">
            <feTurbulence id="turbulence" type="fractalNoise" baseFrequency="0.00001" numOctaves="2" result="noise" />
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="20" />
        </filter>
    </svg>

    <nav>
        <div class="nav-link" onclick="toggleAbout(true)">ABOUT</div>
    </nav>

    <section class="hero">
        <div class="hero-bg-slider">
            <img src="tree1.webp" class="hero-bg-slide" alt="tree1" fetchpriority="high">
            <img data-src="tree2.webp" class="hero-bg-slide" alt="tree2">
            <img data-src="cry1.webp" class="hero-bg-slide" alt="cry1">
            <img data-src="tree4.jpg" class="hero-bg-slide" alt="tree4">
            <img data-src="tree5.webp" class="hero-bg-slide" alt="tree5">
            <img data-src="map1.webp" class="hero-bg-slide" alt="map1">
            <img data-src="carton.webp" class="hero-bg-slide" alt="carton">
        </div>
        <div class="hero-overlay"></div>
        <h1>PORTFOLIO</h1>
        <h2>RAVYN</h2>
    </section>

    <div class="project-section">
        <!-- Graduation Design Special Item -->
        <div class="project-item" onclick="toggleGradMenu(true)">
            <div class="project-image-box"><img src="firstphoto.jpg" alt="Graduation Design"></div>
            <!-- Using house.png as placeholder -->
            <div class="project-content">
                <span>2O25 GRADUATION DESIGN</span>
                <h3>阡陌</h3> <!-- Placeholder Title -->
                <p>從農業的探討，到都市尺度空間的剖析，以及多族群的融入，讓人們透過一連串空間的體驗，喚起對生態、原野的歸屬；將既有農業再提升，尋回緊密的鄰里關係；有意識地創造一個集體對於未來生活型態的精神，打造一個與自然共生與族群共榮的融合介面。
                </p>
            </div>
        </div>

        <div class="project-item" onclick="openBook('p1', 8)">
            <div class="project-image-box"><img src="Protfolio01.webp" alt=""></div>
            <div class="project-content">
                <span>2024 PROJECT O1</span>
                <h3>Wildfire Prevention Skyscraper</h3>
                <p>這座防火摩天大樓旨在應對森林火災風險，特別是北加州等高風險地區。大樓採用先進技術，如無人機進行預防性滅火，並使用新型環保阻燃液體，長時間附著於植被上，提供持久防火效果。此外，無人機還將當地原生植物運送至火災區域，協助生態恢復。建築內設有逃生指示無人機系統，確保火災時提供清晰指引。設計還結合防火牧場，利用山羊放牧清除可燃植物，建立自然防火線。
                </p>
            </div>
        </div>

        <div class="project-item" onclick="openBook('p2', 6)">
            <div class="project-image-box"><img src="house.webp" alt=""></div>
            <div class="project-content">
                <span>2O23 INTERNSHIP</span>
                <h3>Bamboo construction ttakuban practical course</h3>
                <p>實習期間參與台灣築構學苑普悠瑪竹構傳承實作課程，認識普悠瑪部落特有TTAKUBAN（少年會所）的竹構建築與工法，見證傳統材料的可行性與美學價值。</p>
            </div>
        </div>

        <div class="project-item" onclick="openBook('p3', 7)">
            <div class="project-image-box"><img src="flower.webp" alt=""></div>
            <div class="project-content">
                <span>2O23 COMPETITION</span>
                <h3>The 5th National Youth Landscape Competition</h3>
                <p>鳥巢是鳥兒歸巢休憩的場所，因此我們將人類比作為鳥，創造一個能讓人聚集並放鬆的空間，使人進入其中時，能夠感受到如同鳥兒回到巢中的溫暖與安穩。我們的設計意圖模擬鳥巢在樹枝間的自然形態，讓光線穿過樹葉間的縫隙，灑落進巢內，帶來光影的變化，讓人在其中徜徉，感受時光與空間的流動。
                </p>
            </div>
        </div>

        <div class="project-item" onclick="openBook('p4', 9)">
            <div class="project-image-box"><img src="unity.webp" alt=""></div>
            <div class="project-content">
                <span>2O23 PROJECT O2</span>
                <h3>UNITY PLAZA</h3>
                <p>一個將展覽、市集與公園融合的多功能空間。模糊藝術與日常生活界限的場所，讓每個人無論是藝術愛好者、創作者還是普通市民，都能在這裡找到屬於自己的一片天地。這個設計不僅僅是一個建築，它是社區生活的延伸，是藝術與人群間的對話平台，讓藝術無處不在，並且深深融入人們的日常
                </p>
            </div>
        </div>

        <div class="project-item" onclick="openBook('p5', 4)">
            <div class="project-image-box"><img src="garden.webp" alt=""></div>
            <div class="project-content">
                <span>2O23 PROJECT O3</span>
                <h3>Modular Market Garden</h3>
                <p>將市集攤位與公園空間巧妙結合，創造一個多功能的社區場所。模矩化的攤販設計，提升整體美觀與管理性，並為品牌展示提供理想平台。市集提供各式食物、藝術品和手工藝品，滿足市民多樣需求；而公園則提供綠意盎然的休憩空間，讓人們在此放鬆、社交、享受城市文化。設計中的遮陽板採用滑軌伸縮系統，根據天氣需求靈活調整，提供陰涼的同時也能縮回以節省空間，提升場地利用效率。
                </p>
            </div>
        </div>

        <div class="project-item" onclick="openBook('p6', 6)">
            <div class="project-image-box"><img src="tiny.webp" alt=""></div>
            <div class="project-content">
                <span>2O23 PROJECT O4</span>
                <h3>Building a Tiny Box</h3>
                <p>這個建築設計是一個24小時營業的複合式建築，擁有一個下沉式廣場，通過室內外空間的層次變化，提升了視覺享受。下沉式設計不僅改善了地下空間的採光、通風和隔音效果，還有效解決了基地周圍的噪音問題。動線組織巧妙地連接了步道、天橋和屋頂空間，讓不同功能區域相互交織，鼓勵使用者在其中穿梭，達到運動和休憩的目的。
                </p>
            </div>
        </div>

        <div class="project-item" onclick="openBook('p7', 7)">
            <div class="project-image-box"><img src="Intergenerational.webp" alt=""></div>
            <div class="project-content">
                <span>2O22 PROJECT O5</span>
                <h3>Intergenerational Co-living</h3>
                <p>這個建築項目是一個面向高齡社會需求的兩家人住宅，注重健康與永續發展。透過共享住宅的設計，這座住宅將傳統家庭空間與現代共居理念相結合，提供兩家人各自擁有私人空間的同時，也鼓勵共同生活與互動建築形式和構造系統的設計注重環境永續，採用了自然通風、綠化屋頂、雨水回收等環保措施。
                </p>
            </div>
        </div>

        <div class="project-item" onclick="openBook('p8', 4)">
            <div class="project-image-box"><img src="kai.webp" alt=""></div>
            <div class="project-content">
                <span>2O22 PROJECT 06</span>
                <h3>Kaiyuan Temple model Making</h3>

            </div>
        </div>

        <div id="about-overlay">
            <div class="close-btn" onclick="toggleAbout(false)">CLOSE ✕</div>
            <div class="about-content">
                <div class="about-photo"><img src="tsai.jpg" alt=""></div>
                <div class="about-text" id="about-text-anim">
                    <div class="about-header">
                        <h2>蔡卓霖 <span>Tsai Cho Lin</span></h2>
                    </div>
                    <div class="info-grid">
                        <div class="info-item">
                            <h4>EDUCATION</h4>
                            <p>逢甲大學 建築學士學位學程<br>Feng Chia University Bachelor of Architecture Program</p>
                        </div>
                        <div class="info-item">
                            <h4>EXPERIENCE</h4>
                            <ul>
                                <li>李浚營建築師事務所 實習 | Internship</li>
                                <li>大藏聯合建築師事務所 實習 | Internship</li>
                                <li>DVCH DEVILLARCHACON 海外深度實習 | Overseas Internship</li>
                                <li>台灣普悠瑪部落傳統竹構造課程助理 | Assistant</li>
                            </ul>
                        </div>
                        <div class="info-item">
                            <h4>AWARD</h4>
                            <p>第五屆全國青年景觀競賽 優選</p>
                        </div>
                        <div class="info-item">
                            <h4>SKILLS</h4>
                            <p>SKETCHUP / RHINO / ARCHICAD / AUTOCAD<br>INDESIGN / PHOTOSHOP / ILLUSTRATOR</p>
                        </div>
                        <div class="info-item">
                            <h4>CONTACT</h4>
                            <p>T: 0902293812<br>E: ravynooo.ooo@gmail.com</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="book-overlay">
            <div class="back-book" onclick="backToGradMenu()">BACK</div>
            <div class="close-book" onclick="closeBook()">CLOSE ✕</div>
            <div class="nav-arrow prev-arrow" onclick="moveSlide(-1)">❮</div>
            <div class="nav-arrow next-arrow" onclick="moveSlide(1)">❯</div>
            <div id="image-viewer"></div>
        </div>

        <div id="gallery-overlay">
            <div class="back-book" onclick="backToGradMenu()">BACK</div>
            <div class="close-book" onclick="closeBook()">CLOSE ✕</div>
            <div id="gallery-stage">
                <div id="gallery-spinner">
                    <!-- Gallery Items will be injected here JS -->
                </div>
            </div>
        </div>

        <div id="collage-lightbox" onclick="closeCollageLightbox()" style="touch-action: none;">
            <img src="" id="lightbox-img" alt="Enlarged Model Photo">
        </div>

        <footer>© 2026 TSAI CHO LIN. ALL RIGHTS RESERVED.</footer>

        <!-- Graduation Selection Menu -->
        <div id="grad-menu">
            <div class="grad-bg-slider">
                <img src="tree1.webp" class="grad-bg-slide active" alt="bg" fetchpriority="high">
                <img data-src="tree2.webp" class="grad-bg-slide" alt="bg">
                <img data-src="tree3.webp" class="grad-bg-slide" alt="bg">
                <img data-src="tree4.jpg" class="grad-bg-slide" alt="bg">
                <img data-src="tree5.webp" class="grad-bg-slide" alt="bg">
            </div>
            <div class="grad-overlay"></div>

            <div class="grad-close" onclick="toggleGradMenu(false)">CLOSE ✕</div>
            <div class="grad-title">GRADUATION DESIGN</div>
            <div class="grad-options">
                <div class="grad-item item-book" onclick="openGradBook('book')">
                    <h4>Picture Book<br>繪本</h4>
                </div>
                <div class="grad-item item-proposal" onclick="openGradBook('proposal')">
                    <h4>Proposal<br>計劃書</h4>
                </div>
                <div class="grad-item item-design" onclick="openGradBook('design')">
                    <h4>Design<br>設計圖面</h4>
                </div>
                <div class="grad-item item-model" onclick="openGradBook('model')">
                    <h4>Model<br>模型</h4>
                </div>
            </div>
        </div>

        <script>
            gsap.registerPlugin(ScrollTrigger);

            // 1. 波浪動態
            const turb = document.querySelector('#turbulence');
            window.addEventListener('mousemove', (e) => {
                if (window.scrollY < window.innerHeight) {
                    const xVal = (e.clientX / window.innerWidth) * 0.02;
                    const yVal = (e.clientY / window.innerHeight) * 0.01;
                    gsap.to(turb, { attr: { baseFrequency: `${xVal} ${yVal}` }, duration: 0.5 });
                }
            });

            // 2. 滾動動畫 (Responsive)
            const isMobile = window.innerWidth < 768;

            document.querySelectorAll('.project-item').forEach((item) => {
                // Config based on device
                const scrubValue = isMobile ? 0.2 : 1.5; // Very tight response on mobile to remove "delay" feel
                const startScale = isMobile ? 0.85 : 0.65;
                const triggerStart = isMobile ? "top 85%" : "top bottom";
                const triggerEnd = isMobile ? "bottom 10%" : "bottom top";

                // Clear any CSS set props to ensure GSAP clean start
                gsap.set(item, { clearProps: "all" });

                const tl = gsap.timeline({
                    scrollTrigger: {
                        trigger: item,
                        start: triggerStart,
                        end: triggerEnd,
                        scrub: scrubValue,
                    }
                });

                if (isMobile) {
                    // Mobile: Snappy Stagger (Fast Grow -> Snap to Bright)
                    tl.fromTo(item,
                        { scale: startScale, opacity: 0.2 },
                        { scale: 1, opacity: 0.2, duration: 0.25, ease: "power1.out" } // Step 1: Fast Grow
                    )
                        .to(item,
                            { opacity: 1, duration: 0.15, ease: "none" } // Step 2: Snap Brightness (Almost instant)
                        );
                } else {
                    // Desktop: Simultaneous (Grow & Brighten together)
                    tl.fromTo(item,
                        { scale: startScale, opacity: 0.2 },
                        { scale: 1, opacity: 1, duration: 0.5, ease: "power2.out" }
                    );
                }

                // Common Exit
                tl.to(item,
                    { scale: startScale, opacity: 0.2, duration: 0.5, ease: "power2.in" },
                    "+=3" // Long Hold
                );
            });

            // --- NEW: Graduation Menu Logic ---
            let gradInterval;

            function toggleGradMenu(show) {
                const menu = document.getElementById('grad-menu');
                if (show) {
                    console.log("Opening Grad Menu");
                    menu.style.display = 'flex';
                    menu.style.opacity = '1';
                    menu.classList.add('active');
                    document.body.style.overflow = 'hidden';

                    // Start Slideshow
                    const slides = document.querySelectorAll('.grad-bg-slide');
                    let curIndex = 0;
                    // Reset to first slide
                    slides.forEach(s => s.classList.remove('active'));
                    slides[0].classList.add('active');

                    if (gradInterval) clearInterval(gradInterval);
                    gradInterval = setInterval(() => {
                        slides[curIndex].classList.remove('active');
                        curIndex = (curIndex + 1) % slides.length;

                        // Performance: Check and load data-src if exists
                        const nextSlide = slides[curIndex];
                        if (nextSlide.dataset.src) {
                            nextSlide.src = nextSlide.dataset.src;
                            nextSlide.removeAttribute('data-src');
                        }

                        nextSlide.classList.add('active');
                    }, 2800); // Change every 3 seconds

                } else {
                    console.log("Closing Grad Menu");
                    menu.style.opacity = '0';
                    menu.classList.remove('active');
                    setTimeout(() => {
                        if (menu.style.opacity === '0') menu.style.display = 'none';
                    }, 400);
                    document.body.style.overflow = 'auto';

                    // Stop Slideshow
                    if (gradInterval) clearInterval(gradInterval);
                }
            }

            function backToGradMenu() {
                // Close viewers
                const bookOverlay = document.getElementById('book-overlay');
                const collageOverlay = document.getElementById('collage-overlay');

                bookOverlay.classList.remove('active');
                if (document.getElementById('gallery-overlay')) document.getElementById('gallery-overlay').classList.remove('active');

                setTimeout(() => {
                    bookOverlay.style.display = 'none';
                    if (document.getElementById('gallery-overlay')) document.getElementById('gallery-overlay').style.display = 'none';
                }, 300);

                // Re-open Menu
                toggleGradMenu(true);
            }

            function openGradBook(category) {
                const counts = {
                    'book': 24,
                    'model': 21,
                    'design': 2,
                    'proposal': 68
                };

                const folderName = `grad_${category}`;

                toggleGradMenu(false); // Close menu
                setTimeout(() => {
                    if (category === 'model') {
                        openGalleryViewer(folderName, counts[category]);
                    } else {
                        const isMob = window.innerWidth <= 768;
                        let mode = 'single';
                        if (category === 'proposal' && !isMob) mode = 'spread';
                        if (category === 'design' && !isMob) mode = 'vertical';

                        const ext = category === 'design' ? 'jpg' : 'webp';
                        openBook(folderName, counts[category], ext, mode);
                        // Show Back Button explicitly for Grad projects
                    }
                    document.querySelectorAll('.back-book').forEach(el => el.style.display = 'block');
                }, 300);
            }

<<<<<<< HEAD
            // --- Active Memory Manager (Virtualization) ---
            let backgroundPreloadActive = true;
            let memManagerInterval = null;
=======
            // --- Lazy Loading & Preload Control ---
            let backgroundPreloadActive = true;
            let observer = null;
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa

            function stopBackgroundPreload() {
                backgroundPreloadActive = false;
                console.log("Background preload paused for user interaction.");
            }

<<<<<<< HEAD
            // Aggressive memory release
            function initMemoryManager(viewer) {
                if (memManagerInterval) clearInterval(memManagerInterval);

                const updateVisibility = () => {
                    const scrollLeft = viewer.scrollLeft;
                    const width = viewer.offsetWidth;
                    if (width === 0) return; // invisible

                    const currentIndex = Math.round(scrollLeft / width);

                    // SAFE ZONE: Current +/- 1 slide. 
                    // Everything else MUST be unloaded to save memory (35MP images = ~130MB RAM each)
                    const minIdx = currentIndex - 1;
                    const maxIdx = currentIndex + 1;

                    const slides = viewer.querySelectorAll('.img-slide');
                    slides.forEach((slide, idx) => {
                        const imgs = slide.querySelectorAll('img');

                        if (idx >= minIdx && idx <= maxIdx) {
                            // LOAD
                            imgs.forEach(img => {
                                if (!img.src && img.dataset.lazySrc) {
                                    img.src = img.dataset.lazySrc;
                                }
                            });
                        } else {
                            // UNLOAD (Virtualize)
                            imgs.forEach(img => {
                                if (img.src && img.src !== "") {
                                    img.removeAttribute('src'); // Force drop from RAM
                                }
                            });
                        }
                    });
                };

                // Run on scroll (throttled)
                let ticking = false;
                viewer.addEventListener('scroll', () => {
                    if (!ticking) {
                        window.requestAnimationFrame(() => {
                            updateVisibility();
                            ticking = false;
                        });
                        ticking = true;
                    }
                }, { passive: true });

                // Run immediately to load initial
                setTimeout(updateVisibility, 50);
            }

            // 3. 左右翻頁圖片瀏覽器 (Virtual Memory Version)
            function openBook(folder, count, ext = 'webp', mode = 'single') {
                stopBackgroundPreload();
=======
            function initLazyObserver(viewer) {
                if (observer) observer.disconnect();

                observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const slide = entry.target;
                            const imgs = slide.querySelectorAll('img[data-lazy-src]');
                            imgs.forEach(img => {
                                img.src = img.dataset.lazySrc;
                                img.removeAttribute('data-lazy-src');
                            });
                            observer.unobserve(slide);
                        }
                    });
                }, {
                    root: viewer,
                    rootMargin: '100% 0px' // Preload 1 screen ahead
                });
            }

            // 3. 左右翻頁圖片瀏覽器 (Lazy Load Version)
            function openBook(folder, count, ext = 'webp', mode = 'single') {
                stopBackgroundPreload(); // Stop background tasks immediately

                // Reset state: Hide back button by default
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                document.querySelector('.back-book').style.display = 'none';

                const viewer = document.getElementById('image-viewer');
                viewer.innerHTML = '';

<<<<<<< HEAD
                // Helper: Create image with persistent data-lazy-src
                const createVirtualImg = (f, i, e) => {
=======
                // Initialize Lazy Observer
                initLazyObserver(viewer);

                // Helper to create lazy image
                const createLazyImg = (f, i, e, eager = false) => {
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                    const img = document.createElement('img');
                    img.decoding = 'sync';
                    img.dataset.fallbackStage = '0';
                    const src = `${f}/${i}.${e}`;

<<<<<<< HEAD
                    img.dataset.lazySrc = src;
                    // Initial state: EMPTY. Let memory manager load it if visible.

                    img.onerror = function () {
                        // Fallback logic
                        if (e === 'webp' && img.dataset.fallbackStage === '0') {
                            img.dataset.fallbackStage = '1';
                            const newSrc = `${f}/${i}.jpg`;
                            img.dataset.lazySrc = newSrc; // Update source of truth
                            img.src = newSrc;
=======
                    img.onerror = function () {
                        // Fallback logic (WebP -> JPG -> PNG)
                        if (e === 'webp' && img.dataset.fallbackStage === '0') {
                            img.dataset.fallbackStage = '1';
                            img.src = `${f}/${i}.jpg`;
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                            return;
                        }
                        if (e === 'webp' && img.dataset.fallbackStage === '1') {
                            img.dataset.fallbackStage = '2';
<<<<<<< HEAD
                            const newSrc = `${f}/${i}.png`;
                            img.dataset.lazySrc = newSrc;
                            img.src = newSrc;
                            return;
                        }
                    };
=======
                            img.src = `${f}/${i}.png`;
                            return;
                        }
                    };

                    if (eager) {
                        img.loading = 'eager';
                        img.src = src;
                    } else {
                        img.dataset.lazySrc = src;
                        // Placeholder or transparent pixel could go here if needed to hold space, 
                        // but CSS sizing usually handles it if aspect ratio is known.
                        // Here we rely on the container sizing.
                        // To prevent collapse, we might need a placeholder src or style.
                        // For now, let's just leave src empty, but style it.
                        img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // Transparent 1x1
                    }
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                    return img;
                };

                if (mode === 'spread') {
                    viewer.classList.add('spread-mode');
                    viewer.classList.remove('vertical-mode');

<<<<<<< HEAD
                    // 1. Cover
=======
                    // 1. Cover (Always Eager)
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                    const coverSlide = document.createElement('div');
                    coverSlide.className = 'img-slide';
                    const wrapper = document.createElement('div');
                    wrapper.className = 'zoom-wrapper';
<<<<<<< HEAD
                    wrapper.appendChild(createVirtualImg(folder, 1, ext));
                    coverSlide.appendChild(wrapper);
                    viewer.appendChild(coverSlide);

                    // 2. Spreads
=======
                    wrapper.appendChild(createLazyImg(folder, 1, ext, true));
                    coverSlide.appendChild(wrapper);
                    viewer.appendChild(coverSlide);

                    // 2. Rest (Lazy)
                    // Load first spread (pg 2-3) eager as well for smoothness
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                    for (let i = 2; i <= count; i += 2) {
                        const slide = document.createElement('div');
                        slide.className = 'img-slide';
                        const w = document.createElement('div');
                        w.className = 'zoom-wrapper';

<<<<<<< HEAD
                        w.appendChild(createVirtualImg(folder, i, ext));
                        if (i + 1 <= count) w.appendChild(createVirtualImg(folder, i + 1, ext));

                        slide.appendChild(w);
                        viewer.appendChild(slide);
=======
                        const isNearStart = i <= 4; // Preload pg 2,3,4,5
                        w.appendChild(createLazyImg(folder, i, ext, isNearStart));
                        if (i + 1 <= count) w.appendChild(createLazyImg(folder, i + 1, ext, isNearStart));

                        slide.appendChild(w);
                        viewer.appendChild(slide);

                        if (!isNearStart) observer.observe(slide);
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                    }

                } else if (mode === 'vertical') {
                    viewer.classList.remove('spread-mode');
                    viewer.classList.add('vertical-mode');

                    const slide = document.createElement('div');
                    slide.className = 'img-slide';
                    const wrapper = document.createElement('div');
                    wrapper.className = 'zoom-wrapper';

<<<<<<< HEAD
                    // Load all for vertical (small count assumption)
                    for (let i = 1; i <= count; i++) {
                        const img = createVirtualImg(folder, i, ext);
                        img.src = img.dataset.lazySrc;
                        wrapper.appendChild(img);
=======
                    // Vertical mode is a single long scroll, logic differs slightly.
                    // Observer should watch individual images or blocks.
                    // Simplification: For vertical (Design), it's usually just 2 images. Load all.
                    // If vertical gets long, we need wrapper intersection.
                    for (let i = 1; i <= count; i++) {
                        wrapper.appendChild(createLazyImg(folder, i, ext, true));
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                    }
                    slide.appendChild(wrapper);
                    viewer.appendChild(slide);

                } else {
                    // Single Mode
                    viewer.classList.remove('spread-mode');
                    viewer.classList.remove('vertical-mode');

                    for (let i = 1; i <= count; i++) {
                        const slide = document.createElement('div');
                        slide.className = 'img-slide';
                        const w = document.createElement('div');
                        w.className = 'zoom-wrapper';
<<<<<<< HEAD
                        w.appendChild(createVirtualImg(folder, i, ext));
                        slide.appendChild(w);
                        viewer.appendChild(slide);
=======

                        const isNearStart = i <= 3; // First 3 pages eager
                        w.appendChild(createLazyImg(folder, i, ext, isNearStart));
                        slide.appendChild(w);

                        viewer.appendChild(slide);

                        if (!isNearStart) observer.observe(slide);
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                    }
                }

                // Toggle arrows based on mode
                const arrows = document.querySelectorAll('.nav-arrow');
                arrows.forEach(el => el.style.display = (mode === 'vertical') ? 'none' : 'block');

<<<<<<< HEAD
                initZoomLogic();

                // Initialize Memory Manager (Only for horizontal scrollers)
                if (mode !== 'vertical') {
                    initMemoryManager(viewer);
                }

=======
                initZoomLogic(); // Enable zoom
>>>>>>> 7dffca2837668d7efed477a22e06b6fc26428efa
                const overlay = document.getElementById('book-overlay');
                overlay.style.display = 'block';
                setTimeout(() => overlay.classList.add('active'), 10);
                document.body.style.overflow = 'hidden';
                viewer.scrollLeft = 0;
            }

            // --- 照片牆邏輯 (Collage Logic) ---
            let collageZ = 100;
            let hungCount = 0;
            let currentActiveItem = null;

            function openCollageViewer(folder, count) {
                const overlay = document.getElementById('collage-overlay');
                const container = document.getElementById('collage-container');
                const dotsContainer = document.getElementById('collage-dots');

                container.innerHTML = ''; // Clear old items
                dotsContainer.innerHTML = ''; // Clear old dots
                hungCount = 0; // Reset hanging count

                // Show overlay
                overlay.style.display = 'block';
                setTimeout(() => overlay.classList.add('active'), 10);
                document.body.style.overflow = 'hidden';

                const isMob = window.innerWidth < 768;

                if (isMob) {
                    // --- Mobile: Pagination Logic (Scattered 9 per page) ---
                    dotsContainer.style.display = 'flex';
                    const itemsPerPage = 9;
                    const totalPages = Math.ceil(count / itemsPerPage);

                    // Create Pages
                    for (let p = 0; p < totalPages; p++) {
                        const page = document.createElement('div');
                        page.className = 'collage-page';
                        page.dataset.pageIndex = p;

                        const startIdx = p * itemsPerPage + 1;
                        const endIdx = Math.min(startIdx + itemsPerPage - 1, count);

                        for (let i = startIdx; i <= endIdx; i++) {
                            const item = document.createElement('div');
                            item.className = 'collage-item';
                            // Initial state
                            item.style.opacity = '0';
                            item.style.transition = 'opacity 0.5s ease, transform 0.3s cubic-bezier(0.2, 0, 0.2, 1)';

                            const img = createImgElement(folder, i, 'webp');
                            item.appendChild(img);
                            page.appendChild(item);

                            img.onload = () => {
                                const isPortrait = img.naturalHeight > img.naturalWidth;

                                // Mobile sizes
                                let minW = 120, maxW = 180;
                                if (isPortrait) {
                                    minW = 100; maxW = 150;
                                }

                                const itemW = minW + Math.random() * (maxW - minW);
                                item.style.width = `${itemW}px`;

                                // Boundary within the page (100vw, 100vh)
                                // Keep some padding away from edges
                                const itemH = (img.naturalHeight / img.naturalWidth) * itemW;
                                const maxX = window.innerWidth - itemW - 20;
                                const maxY = window.innerHeight - itemH - 80; // Reserve bottom space for dots

                                const randX = 10 + Math.random() * Math.max(0, maxX - 20); // Safe random
                                const randY = 50 + Math.random() * Math.max(0, maxY - 60); // Safe random top offset

                                const randRot = (Math.random() - 0.5) * 20;

                                item.style.left = `${randX}px`;
                                item.style.top = `${randY}px`;
                                item.style.transform = `rotate(${randRot}deg)`;
                                item.style.opacity = '1';

                                item.onclick = () => openCollageLightbox(item);
                            };
                        }
                        container.appendChild(page);

                        // Create Dot
                        const dot = document.createElement('div');
                        dot.className = 'collage-dot';
                        if (p === 0) dot.classList.add('active');
                        dotsContainer.appendChild(dot);
                    }

                    // Mobile Scroll Listener for Dots
                    container.onscroll = () => {
                        const pageW = window.innerWidth;
                        const scrollLeft = container.scrollLeft;
                        const activeIndex = Math.round(scrollLeft / pageW);

                        document.querySelectorAll('.collage-dot').forEach((d, idx) => {
                            if (idx === activeIndex) d.classList.add('active');
                            else d.classList.remove('active');
                        });
                    };

                } else {
                    // --- Desktop: Original Scattered Logic ---
                    dotsContainer.style.display = 'none';

                    for (let i = 1; i <= count; i++) {
                        const item = document.createElement('div');
                        item.className = 'collage-item';
                        item.style.opacity = '0';
                        item.style.transition = 'opacity 0.5s ease, transform 0.3s cubic-bezier(0.2, 0, 0.2, 1)';

                        const img = createImgElement(folder, i, 'webp');
                        item.appendChild(img);
                        container.appendChild(item);

                        img.onload = () => {
                            const isPortrait = img.naturalHeight > img.naturalWidth;

                            let minW = 250, maxW = 330; // Desktop sizes
                            if (!isPortrait) {
                                minW = 350; maxW = 520;
                            }

                            const itemW = minW + Math.random() * (maxW - minW);
                            item.style.width = `${itemW}px`;

                            const itemH = (img.naturalHeight / img.naturalWidth) * itemW;
                            const maxX = window.innerWidth - itemW - 40;
                            const maxY = window.innerHeight - (itemH + 30) - 40;

                            const randX = 20 + Math.random() * maxX;
                            const randY = 20 + Math.random() * maxY;
                            const randRot = (Math.random() - 0.5) * 30;

                            item.style.left = `${randX}px`;
                            item.style.top = `${randY}px`;
                            item.style.transform = `rotate(${randRot}deg)`;
                            item.style.opacity = '1';

                            initCollageDrag(item);
                        };
                    }
                }
            }



            function openCollageLightbox(el) {
                currentActiveItem = el;
                const lightbox = document.getElementById('collage-lightbox');
                const img = document.getElementById('lightbox-img');
                img.src = el.querySelector('img').src;

                // Reset Zoom State
                lightboxState = { scale: 1, x: 0, y: 0 };
                updateTransform();
                img.classList.remove('zoomed'); // Legacy cleanup

                lightbox.style.display = 'flex';
                setTimeout(() => lightbox.classList.add('active'), 10);
            }

            // --- 3D 畫廊邏輯 (3D Gallery Logic) ---
            let galleryRadius = 0;
            let galleryAngle = 0;
            let currentGalleryCount = 0;

            function openGalleryViewer(folder, count) {
                stopBackgroundPreload(); // Stop background tasks

                const overlay = document.getElementById('gallery-overlay');
                const spinner = document.getElementById('gallery-spinner');
                spinner.innerHTML = '';
                currentGalleryCount = count;

                // Show overlay
                overlay.style.display = 'block';
                setTimeout(() => overlay.classList.add('active'), 10);
                document.body.style.overflow = 'hidden';

                // Calculate Radius
                const isMob = window.innerWidth < 768;
                const panelWidth = isMob ? 160 : 250; // Match CSS #gallery-spinner width
                const tanVal = Math.tan(Math.PI / count);
                galleryRadius = Math.round((panelWidth / 2) / tanVal);

                // Adjust radius slightly if too tight or too wide
                // For small counts, radius might be small, for large counts huge.
                // Clamp radius for better visual? Or let it be. 
                // Let's add a minimum gap spacing
                galleryRadius = Math.max(galleryRadius, panelWidth * 1.5);

                // Inject Items with Staggered Loading
                const loadBatch = (start, end) => {
                    for (let i = start; i <= end; i++) {
                        const item = document.createElement('div');
                        item.className = 'gallery-item';
                        const angle = (360 / count) * (i - 1);
                        item.style.transform = `rotateY(${angle}deg) translateZ(${galleryRadius}px)`;
                        const img = createImgElement(folder, i, 'webp');
                        item.appendChild(img);
                        spinner.appendChild(item);
                    }
                };

                // Load first 6 immediately, then stagger rest
                const initial = Math.min(6, count);
                loadBatch(1, initial);

                if (count > initial) {
                    let current = initial + 1;
                    const staggerInterval = setInterval(() => {
                        if (current > count) {
                            clearInterval(staggerInterval);
                            return;
                        }
                        // Batch 3 at a time for efficiency
                        const end = Math.min(current + 2, count);
                        loadBatch(current, end);
                        current = end + 1;
                    }, 100);
                }

                // Initial Position
                galleryAngle = 0;
                spinner.style.transform = `translateZ(-${galleryRadius}px) rotateY(0deg)`;

                initGalleryDrag();
            }

            function initGalleryDrag() {
                if (window.galleryDragInitialized) return;
                window.galleryDragInitialized = true;

                // Listen on overlay effectively (or window)
                const stage = document.getElementById('gallery-overlay');
                const spinner = document.getElementById('gallery-spinner');

                let startX, currentX;
                let isDragging = false;
                let startAngle = 0;
                let lastX = 0;
                let velocity = 0;
                let lastTime = 0;

                const onDown = (e) => {
                    // Only start if clicking stage or spinner, not buttons
                    if (e.target.closest('.close-book') || e.target.closest('.back-book')) return;

                    isDragging = true;
                    spinner.classList.remove('inertia'); // Stop inertia when grabbed
                    spinner.style.transition = 'none'; // PERFORMANCE: Disable transition during drag

                    velocity = 0;
                    startX = e.touches ? e.touches[0].clientX : e.clientX;
                    currentX = startX; // Fix: Initialize currentX for 0-move taps
                    lastX = startX;
                    lastTime = performance.now();

                    startAngle = galleryAngle;
                    // stage is overlay now, so cursor change works if overlay has pointer events
                    stage.style.cursor = 'grabbing';
                };

                const onMove = (e) => {
                    if (!isDragging) return;
                    e.preventDefault(); // Prevent scroll on mobile
                    currentX = e.touches ? e.touches[0].clientX : e.clientX;

                    const now = performance.now();
                    const dt = now - lastTime;
                    const dx = currentX - startX;
                    const deltaX = currentX - lastX;

                    if (dt > 0) {
                        velocity = deltaX / dt;
                    }

                    lastX = currentX;
                    lastTime = now;

                    const sensitivity = 0.25;
                    galleryAngle = startAngle + (dx * sensitivity);

                    spinner.style.transform = `translateZ(-${galleryRadius}px) rotateY(${galleryAngle}deg)`;
                };

                const onUp = (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    stage.style.cursor = 'default';
                    spinner.style.transition = ''; // Restore CSS transition
                    spinner.classList.add('inertia'); // Add inertia back

                    // Tap Detection
                    // If movement is very small, treat as click
                    const totalDist = Math.abs(currentX - startX);
                    if (totalDist < 30) {
                        // Use elementFromPoint to find what is *currently* under the finger
                        const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                        const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

                        const actualTarget = document.elementFromPoint(clientX, clientY);
                        const targetItem = actualTarget ? actualTarget.closest('.gallery-item') : null;

                        if (targetItem) {
                            // Prevent ghost click that might toggle zoom immediately
                            if (e.cancelable) e.preventDefault();
                            openCollageLightbox(targetItem);
                            return; // Stop momentum if tap
                        }
                    }

                    // Apply Momentum
                    const friction = 30;
                    const momentumAngle = velocity * friction;

                    if (Math.abs(momentumAngle) > 1) {
                        galleryAngle += momentumAngle;
                        spinner.style.transform = `translateZ(-${galleryRadius}px) rotateY(${galleryAngle}deg)`;
                    }
                };

                // Use addEventListener for better mobile support (passive: false)
                stage.addEventListener('mousedown', onDown);
                stage.addEventListener('touchstart', onDown, { passive: false });

                window.addEventListener('mousemove', onMove);
                window.addEventListener('touchmove', onMove, { passive: false });

                window.addEventListener('mouseup', onUp);
                window.addEventListener('touchend', onUp);
            }

            function closeCollageLightbox() {
                const lightbox = document.getElementById('collage-lightbox');
                lightbox.classList.remove('active');
                setTimeout(() => {
                    lightbox.style.display = 'none';
                    // Reset zoom on close
                    const img = document.getElementById('lightbox-img');
                    if (img) img.classList.remove('zoomed');
                }, 400);
            }

            // --- Advanced Zoom & Pan Logic for Lightbox ---
            let lightboxState = { scale: 1, x: 0, y: 0 };
            let lightboxDrag = { startX: 0, startY: 0, isDragging: false };
            let pinchStart = { dist: 0, scale: 1 };

            function initLightboxZoom() {
                const img = document.getElementById('lightbox-img');
                const container = document.getElementById('collage-lightbox');
                if (!img || !container) return;

                // Reset state on init
                lightboxState = { scale: 1, x: 0, y: 0 };
                updateTransform();

                // Desktop Wheel Zoom
                container.onwheel = (e) => {
                    e.preventDefault();
                    // Zoom towards mouse cursor could be complex, start with center zoom
                    const delta = -e.deltaY;
                    const factor = delta > 0 ? 1.1 : 0.9;

                    const oldScale = lightboxState.scale;
                    let newScale = oldScale * factor;
                    newScale = Math.min(Math.max(1, newScale), 5); // Limit zoom 1x to 5x

                    // Adjust Scale
                    lightboxState.scale = newScale;

                    // If zoomed out completely, reset pan
                    if (newScale === 1) {
                        lightboxState.x = 0;
                        lightboxState.y = 0;
                    }

                    updateTransform();
                };

                // Desktop Pan (Mouse) with click-to-zoom and drag detection
                img.onmousedown = (e) => {
                    e.preventDefault(); // Stop default drag
                    if (lightboxState.scale <= 1) return;

                    lightboxDrag.isDragging = true;
                    lightboxDrag.hasMoved = false; // track if user actually drags (so click won't toggle zoom)
                    lightboxDrag.startX = e.clientX - lightboxState.x;
                    lightboxDrag.startY = e.clientY - lightboxState.y;
                    img.style.cursor = 'grabbing';
                };

                window.addEventListener('mousemove', (e) => {
                    if (!lightboxDrag.isDragging) return;
                    e.preventDefault();
                    const newX = e.clientX - lightboxDrag.startX;
                    const newY = e.clientY - lightboxDrag.startY;
                    // movement threshold to distinguish click vs drag
                    if (!lightboxDrag.hasMoved && (Math.abs(newX - lightboxState.x) > 3 || Math.abs(newY - lightboxState.y) > 3)) {
                        lightboxDrag.hasMoved = true;
                    }
                    lightboxState.x = newX;
                    lightboxState.y = newY;
                    updateTransform();
                });

                window.addEventListener('mouseup', (e) => {
                    if (lightboxDrag.isDragging) {
                        lightboxDrag.isDragging = false;
                        const imgEl = document.getElementById('lightbox-img');
                        if (imgEl) imgEl.style.cursor = 'default'; // cursor handling
                        // short timeout to allow click event to check moved flag
                        setTimeout(() => { lightboxDrag.hasMoved = false; }, 50);
                    }
                });

                // Prevent overlay close when interacting with image; toggle zoom on click (cycle 1 -> 2 -> 4 -> 1)
                img.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // If we just dragged, don't treat as click to toggle zoom
                    if (lightboxDrag.hasMoved) {
                        lightboxDrag.hasMoved = false;
                        return;
                    }
                    const levels = [1, 2, 4];
                    const cur = lightboxState.scale || 1;
                    let idx = levels.findIndex(l => Math.abs(cur - l) < 0.5);
                    if (idx === -1) {
                        // choose closest
                        idx = levels.map(l => Math.abs(cur - l)).reduce((minI, x, i, arr) => x < arr[minI] ? i : minI, 0);
                    }
                    const next = levels[(idx + 1) % levels.length];
                    if (next === 1) {
                        lightboxState = { scale: 1, x: 0, y: 0 };
                    } else {
                        lightboxState.scale = next;
                    }
                    updateTransform();
                });

                // Touch single-tap support: prevent close and toggle zoom on tap
                let lastTouchEnd = 0;
                img.addEventListener('touchend', (e) => {
                    e.stopPropagation();
                    const now = Date.now();
                    // avoid double triggers
                    if (Math.abs(now - lastTouchEnd) < 300) return;
                    if (lightboxDrag.isDragging) return;
                    const levels = [1, 2, 4];
                    const cur = lightboxState.scale || 1;
                    let idx = levels.findIndex(l => Math.abs(cur - l) < 0.5);
                    if (idx === -1) idx = levels.map(l => Math.abs(cur - l)).reduce((minI, x, i, arr) => x < arr[minI] ? i : minI, 0);
                    const next = levels[(idx + 1) % levels.length];
                    if (next === 1) {
                        lightboxState = { scale: 1, x: 0, y: 0 };
                    } else {
                        lightboxState.scale = next;
                    }
                    updateTransform();
                    lastTouchEnd = now;
                });

                // Mobile Pinch & Pan
                // Using container listeners to catch everything
                container.addEventListener('touchstart', onTouchStart, { passive: false });
                container.addEventListener('touchmove', onTouchMove, { passive: false });
                container.addEventListener('touchend', onTouchEnd);
            }

            // Mobile Touch Handlers
            let lastTouchX = 0, lastTouchY = 0;

            function onTouchStart(e) {
                if (e.touches.length === 1) {
                    // Pan Start
                    if (lightboxState.scale > 1) {
                        lightboxDrag.isDragging = true;
                        lastTouchX = e.touches[0].clientX;
                        lastTouchY = e.touches[0].clientY;
                    }
                } else if (e.touches.length === 2) {
                    // Pinch Start
                    lightboxDrag.isDragging = false; // Stop panning
                    const dist = getDist(e.touches[0], e.touches[1]);
                    pinchStart = { dist: dist, scale: lightboxState.scale };
                }
            }

            function onTouchMove(e) {
                if (e.touches.length === 1 && lightboxDrag.isDragging) {
                    // Pan Move
                    e.preventDefault();
                    const dx = e.touches[0].clientX - lastTouchX;
                    const dy = e.touches[0].clientY - lastTouchY;

                    lightboxState.x += dx;
                    lightboxState.y += dy;

                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;

                    updateTransform();

                } else if (e.touches.length === 2) {
                    // Pinch Move
                    e.preventDefault();
                    const dist = getDist(e.touches[0], e.touches[1]);
                    const scaleFactor = dist / pinchStart.dist;

                    let newScale = pinchStart.scale * scaleFactor;
                    newScale = Math.min(Math.max(1, newScale), 5);

                    lightboxState.scale = newScale;
                    if (newScale === 1) {
                        lightboxState.x = 0;
                        lightboxState.y = 0;
                    }
                    updateTransform();
                }
            }

            function onTouchEnd(e) {
                if (e.touches.length < 2) {
                    // reset pinch logic?
                }
                if (e.touches.length === 0) {
                    lightboxDrag.isDragging = false;
                }
            }

            function getDist(t1, t2) {
                return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            }

            function updateTransform() {
                const img = document.getElementById('lightbox-img');
                if (!img) return;
                // Clamp Pan to view
                // Simple clamp: don't let edge cross center? 
                // For now, free pan (user requested "drag where they want")

                img.style.transform = `translate(${lightboxState.x}px, ${lightboxState.y}px) scale(${lightboxState.scale})`;
            }

            // --- NEW: Zoom & Pan Logic ---
            let zoomStates = new Map(); // WeakMap better if elements removed, but viewer cleared every time

            function initZoomLogic() {
                const viewer = document.getElementById('image-viewer');

                // Limit max scale on mobile to prevent memory crash/flickering
                const IS_MOBILE = window.innerWidth <= 768;
                const MAX_SCALE = IS_MOBILE ? 3 : 12;

                // Wheel Zoom (Desktop) with Mouse-Following Pan Calculation
                viewer.onwheel = (e) => {
                    const slide = getActiveSlide();
                    if (!slide) return;
                    const wrapper = slide.querySelector('.zoom-wrapper');
                    if (!wrapper) return;

                    e.preventDefault();

                    let state = zoomStates.get(wrapper) || { scale: 1, x: 0, y: 0 };

                    const rect = wrapper.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    // Mouse relative to center (for stable zoom)
                    const mouseX = e.clientX - centerX;
                    const mouseY = e.clientY - centerY;

                    const delta = -e.deltaY;
                    const factor = delta > 0 ? 1.1 : 0.9;

                    const oldScale = state.scale;
                    let newScale = oldScale * factor;
                    newScale = Math.min(Math.max(1, newScale), MAX_SCALE);

                    const ratio = newScale / oldScale;

                    // Adjust position to keep mouse stationary
                    state.x += mouseX * (1 - ratio);
                    state.y += mouseY * (1 - ratio);
                    state.scale = newScale;

                    if (state.scale <= 1.01) {
                        state.scale = 1;
                        state.x = 0;
                        state.y = 0;
                    }

                    zoomStates.set(wrapper, state);
                    applyTransform(wrapper, state);
                };

                // Mouse Drag & Click-to-Zoom logic
                let isDragging = false;
                let hasMoved = false; // Distinguish click vs drag
                let startX, startY;

                viewer.onmousedown = (e) => {
                    e.preventDefault();
                    const slide = getActiveSlide();
                    const wrapper = slide?.querySelector('.zoom-wrapper');
                    if (!wrapper) return;

                    let state = zoomStates.get(wrapper) || { scale: 1, x: 0, y: 0 };

                    // Allow dragging only if zoomed in
                    if (state.scale > 1) {
                        isDragging = true;
                        hasMoved = false;
                        wrapper.classList.add('dragging');
                        startX = e.clientX - state.x;
                        startY = e.clientY - state.y;
                    }
                };

                window.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    const slide = getActiveSlide();
                    const wrapper = slide?.querySelector('.zoom-wrapper');
                    if (!wrapper) return;

                    let state = zoomStates.get(wrapper);
                    if (!state) return;

                    // Check movement threshold
                    if (!hasMoved) {
                        if (Math.abs(e.clientX - startX - state.x) > 3 || Math.abs(e.clientY - startY - state.y) > 3) {
                            hasMoved = true;
                        }
                    }

                    state.x = e.clientX - startX;
                    state.y = e.clientY - startY;
                    applyTransform(wrapper, state);
                });

                window.addEventListener('mouseup', (e) => {
                    if (isDragging) {
                        isDragging = false;
                        const wrappers = document.querySelectorAll('.zoom-wrapper');
                        wrappers.forEach(w => w.classList.remove('dragging'));
                        setTimeout(() => hasMoved = false, 50);
                    }
                });

                // Click to Toggle Zoom (1x <-> 4x)
                viewer.onclick = (e) => {
                    if (hasMoved) return; // Verify it wasn't a drag operation
                    // Check if clicked on an image
                    if (!e.target.closest('img')) return;

                    const slide = getActiveSlide();
                    const wrapper = slide?.querySelector('.zoom-wrapper');
                    if (!wrapper) return;

                    let state = zoomStates.get(wrapper) || { scale: 1, x: 0, y: 0 };

                    // Simple toggle: If zoomed out, zoom in to 4x. If zoomed in, reset.
                    if (state.scale > 1.1) {
                        state.scale = 1;
                        state.x = 0;
                        state.y = 0;
                    } else {
                        // Zoom in to 4x centered on click
                        const rect = wrapper.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;

                        // Vector from center to click
                        const mouseX = e.clientX - centerX;
                        const mouseY = e.clientY - centerY;

                        const newScale = 4;
                        const oldScale = 1; // Assuming we start from 1
                        const ratio = newScale / oldScale;

                        // T_new = V - (V - T_old) * ratio => V - V * ratio (since T_old is 0)
                        // T_new = V * (1 - ratio) = V * (1 - 4) = -3 * V
                        state.x = mouseX * (1 - ratio);
                        state.y = mouseY * (1 - ratio);
                        state.scale = newScale;
                    }

                    zoomStates.set(wrapper, state);
                    applyTransform(wrapper, state);
                };

                // --- Touch Logic (Pinch & Pan) ---
                let lastTouchX = 0, lastTouchY = 0;
                let touchPinchStart = { dist: 0, scale: 1 };
                let isTouchDragging = false;

                viewer.addEventListener('touchstart', (e) => {
                    const slide = getActiveSlide();
                    const wrapper = slide?.querySelector('.zoom-wrapper');
                    if (!wrapper) return;

                    // Dynamic GPU: Enable for smooth interaction
                    wrapper.style.willChange = 'transform';

                    let state = zoomStates.get(wrapper) || { scale: 1, x: 0, y: 0 };

                    if (e.touches.length === 1) {
                        // Pan Start
                        if (state.scale > 1) {
                            isTouchDragging = true;
                            lastTouchX = e.touches[0].clientX;
                            lastTouchY = e.touches[0].clientY;
                        }
                    } else if (e.touches.length === 2) {
                        // Pinch Start
                        isTouchDragging = false;
                        const dist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        touchPinchStart = { dist: dist, scale: state.scale };
                        e.preventDefault();
                    }
                }, { passive: false });

                viewer.addEventListener('touchmove', (e) => {
                    const slide = getActiveSlide();
                    const wrapper = slide?.querySelector('.zoom-wrapper');
                    if (!wrapper) return;
                    let state = zoomStates.get(wrapper) || { scale: 1, x: 0, y: 0 };

                    if (e.touches.length === 1 && isTouchDragging) {
                        // Pan
                        e.preventDefault();
                        const dx = e.touches[0].clientX - lastTouchX;
                        const dy = e.touches[0].clientY - lastTouchY;
                        state.x += dx;
                        state.y += dy;
                        lastTouchX = e.touches[0].clientX;
                        lastTouchY = e.touches[0].clientY;
                        applyTransform(wrapper, state);
                    } else if (e.touches.length === 2) {
                        // Pinch
                        e.preventDefault();
                        const dist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        const scaleFactor = dist / touchPinchStart.dist;
                        state.scale = Math.min(Math.max(1, touchPinchStart.scale * scaleFactor), MAX_SCALE);

                        if (state.scale <= 1.1) {
                            state.scale = 1;
                            state.x = 0;
                            state.y = 0;
                        }

                        zoomStates.set(wrapper, state);
                        applyTransform(wrapper, state);
                    }
                }, { passive: false });

                viewer.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        // Pinch end
                    }
                    if (e.touches.length === 0) {
                        isTouchDragging = false;

                        // Dynamic GPU: Disable correctly to allow re-rasterization (Sharpen image)
                        const slide = getActiveSlide();
                        const wrapper = slide?.querySelector('.zoom-wrapper');
                        if (wrapper) {
                            setTimeout(() => {
                                wrapper.style.willChange = 'auto';
                            }, 100);
                        }
                    }
                });
            }

            function getActiveSlide() {
                const viewer = document.getElementById('image-viewer');
                const slides = viewer.querySelectorAll('.img-slide');
                const scrollLeft = viewer.scrollLeft;
                const index = Math.round(scrollLeft / window.innerWidth);
                return slides[index];
            }

            function applyTransform(el, state) {
                el.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
            }

            function resetAllZooms() {
                zoomStates.clear();
                document.querySelectorAll('.zoom-wrapper').forEach(w => {
                    w.style.transform = 'none';
                });
            }

            // Reset zoom when resizing or scrolling to new slide
            document.getElementById('image-viewer').addEventListener('scroll', () => {
                // Potential optimization: only reset if scale > 1
                // For now, simple approach: reset if moving away significantly
            }, { passive: true });

            function createImgElement(folder, i, ext) {
                const img = document.createElement('img');
                img.loading = 'eager'; // User request: eager
                img.decoding = 'sync'; // User request: sync (prevent flash)
                img.dataset.fallbackStage = '0';

                img.onerror = function () {
                    // If we first tried webp, fallback to jpg then png
                    if (ext === 'webp' && img.dataset.fallbackStage === '0') {
                        img.dataset.fallbackStage = '1';
                        img.src = `${folder}/${i}.jpg`;
                        return;
                    }
                    if (ext === 'webp' && img.dataset.fallbackStage === '1') {
                        img.dataset.fallbackStage = '2';
                        img.src = `${folder}/${i}.png`;
                        return;
                    }
                    console.error("Failed to load image:", img.src);
                    const errorText = document.createElement('div');
                    errorText.style.color = "white";
                    errorText.style.position = "absolute";
                    errorText.style.background = "rgba(255,0,0,0.5)";
                    errorText.style.padding = "5px";
                    errorText.innerText = `Image not found: ${folder}/${i}.${ext}`;
                    if (img.parentNode) img.parentNode.appendChild(errorText);
                };

                img.src = `${folder}/${i}.${ext}`;
                return img;
            }

            function moveSlide(direction) {
                resetAllZooms(); // Reset zoom when moving to another page
                const viewer = document.getElementById('image-viewer');
                viewer.scrollBy({ left: direction * window.innerWidth, behavior: 'smooth' });
            }

            function closeBook() {
                const bookOverlay = document.getElementById('book-overlay');
                const galleryOverlay = document.getElementById('gallery-overlay');

                bookOverlay.classList.remove('active');
                if (galleryOverlay) galleryOverlay.classList.remove('active');

                setTimeout(() => {
                    bookOverlay.style.display = 'none';
                    if (galleryOverlay) galleryOverlay.style.display = 'none';
                }, 400);
                document.body.style.overflow = 'auto';
            }

            function toggleAbout(open) {
                const overlay = document.getElementById('about-overlay');
                overlay.style.display = open ? 'flex' : 'none';
                document.body.style.overflow = open ? 'hidden' : 'auto';
                if (open) gsap.fromTo("#about-text-anim", { y: 30, opacity: 0 }, { y: 0, opacity: 1, duration: 0.8 });
            }
            // --- NEW: Hero Background Random Slider ---
            document.addEventListener('DOMContentLoaded', () => {
                const heroSlides = document.querySelectorAll('.hero-bg-slide');
                if (heroSlides.length > 0) {
                    // 1. Random Start
                    let heroIndex = Math.floor(Math.random() * heroSlides.length);
                    const startSlide = heroSlides[heroIndex];
                    if (startSlide.dataset.src) {
                        startSlide.src = startSlide.dataset.src;
                        startSlide.removeAttribute('data-src');
                    }
                    startSlide.classList.add('active');
                    console.log("Hero Random Start Index:", heroIndex);

                    // 2. Auto Cycle
                    setInterval(() => {
                        heroSlides[heroIndex].classList.remove('active');
                        heroIndex = (heroIndex + 1) % heroSlides.length;

                        // Performance: Check and load data-src if exists
                        const nextSlide = heroSlides[heroIndex];
                        if (nextSlide.dataset.src) {
                            nextSlide.src = nextSlide.dataset.src;
                            nextSlide.removeAttribute('data-src');
                        }

                        nextSlide.classList.add('active');
                    }, 3000); // Switch every 3 seconds
                }
            });

            // --- NEW: Loader Logic with Image Preloading ---
            function getAllImageUrls() {
                const urls = new Set();

                // Collect from <img> tags (src and data-src)
                document.querySelectorAll('img').forEach(img => {
                    const dsrc = img.getAttribute('data-src');
                    if (dsrc) urls.add(new URL(dsrc, location.href).href);
                    try {
                        if (img.src && !img.src.startsWith('data:')) urls.add(img.src);
                    } catch (e) { /* ignore malformed */ }
                });

                // Collect data-src attributes from other elements
                document.querySelectorAll('[data-src]').forEach(el => {
                    const v = el.getAttribute('data-src');
                    if (v) urls.add(new URL(v, location.href).href);
                });

                // --- PRELOAD GRADUATION IMAGES (Graduation Design) ---
                // CRITICAL: Only preload the first few images to keep initial load fast (Tier 1)
                const gradFolders = [
                    { folder: 'grad_design', count: 2, ext: 'jpg' },
                    { folder: 'grad_model', count: 21, ext: 'webp' },
                    { folder: 'grad_proposal', count: 68, ext: 'webp' },
                    { folder: 'grad_book', count: 24, ext: 'webp' }
                ];

                gradFolders.forEach(info => {
                    // Preload ALL for design (only 2), but only first 5 for others
                    const limit = (info.folder === 'grad_design') ? info.count : 5;
                    const loopCount = Math.min(info.count, limit);

                    for (let i = 1; i <= loopCount; i++) {
                        urls.add(new URL(`${info.folder}/${i}.${info.ext}`, location.href).href);
                    }
                });

                // Collect background-image from computed styles
                document.querySelectorAll('*').forEach(el => {
                    try {
                        const bg = getComputedStyle(el).backgroundImage;
                        if (bg && bg !== 'none') {
                            const matches = bg.match(/url\(["']?(.*?)["']?\)/g);
                            if (matches) {
                                matches.forEach(m => {
                                    const url = m.replace(/url\(["']?/, '').replace(/["']?\)$/, '');
                                    if (url && !url.startsWith('data:')) {
                                        try { urls.add(new URL(url, location.href).href); } catch (e) { urls.add(url); }
                                    }
                                });
                            }
                        }
                    } catch (e) { /* ignore cross-origin or computed style errors */ }
                });

                return Array.from(urls);
            }

            function preloadImages(urls, onProgress, timeoutMs = 8000) {
                return new Promise(resolve => {
                    if (!urls || urls.length === 0) {
                        if (onProgress) onProgress(1, 1);
                        resolve();
                        return;
                    }

                    let loaded = 0;
                    const total = urls.length;
                    let finished = false;

                    const timer = setTimeout(() => {
                        if (!finished) { finished = true; resolve(); }
                    }, timeoutMs);

                    urls.forEach(url => {
                        const img = new Image();
                        img.onload = img.onerror = () => {
                            loaded++;
                            if (onProgress) onProgress(loaded, total);
                            if (loaded >= total && !finished) {
                                clearTimeout(timer);
                                finished = true;
                                resolve();
                            }
                        };
                        img.src = url;
                    });
                });
            }

            function initLoader() {
                const loader = document.getElementById('loader');
                const percentText = document.getElementById('percent');
                const archLine = document.getElementById('arch-line');

                // Animate SVG path
                gsap.to(archLine, {
                    strokeDashoffset: 0,
                    duration: 2,
                    ease: "power1.inOut",
                    repeat: -1,
                    yoyo: true
                });

                const urls = getAllImageUrls();
                let lastPercent = 0;
                function setPercent(n) {
                    const p = Math.min(100, Math.round(n));
                    if (p !== lastPercent) {
                        lastPercent = p;
                        percentText.innerText = p;
                    }
                }

                if (!urls.length) {
                    // No images to preload — just finish loader quickly
                    setPercent(100);
                    gsap.to(loader, {
                        opacity: 0,
                        duration: 0.8,
                        ease: "power2.inOut",
                        onComplete: () => {
                            loader.style.display = 'none';
                            document.body.style.overflow = 'auto';
                        }
                    });
                    return;
                }

                // Start preloading and update percent based on progress
                preloadImages(urls, (loaded, total) => {
                    // Map to 0..95% while loading, reserve last 5% for final animation
                    const percent = (loaded / total) * 95;
                    setPercent(percent);
                }, 10000 /* timeout 10s */).then(() => {
                    // Animate to 100% then hide loader
                    gsap.to({ p: lastPercent }, {
                        p: 100,
                        duration: 0.6,
                        onUpdate: function () { setPercent(this.targets()[0].p); },
                        onComplete: function () {
                            gsap.to(loader, {
                                opacity: 0,
                                duration: 0.8,
                                ease: "power2.inOut",
                                onComplete: () => {
                                    loader.style.display = 'none';
                                    document.body.style.overflow = 'auto';
                                }
                            });
                        }
                    });
                });
            }

            // --- NEW: Menu Hover Images Preloader ---
            function preloadMenuImages() {
                const hoverImages = [
                    'midle.webp',
                    'modelmenu.webp',
                    'proposal.webp',
                    'kai.webp'
                ];
                hoverImages.forEach(img => {
                    const i = new Image();
                    i.src = img;
                    i.onerror = () => {
                        // If webp not available, try original names
                        if (img.endsWith('.webp')) {
                            const fallback = img.replace('.webp', '.png');
                            i.src = fallback;
                        }
                    };
                });
                console.log("Menu hover images preloaded.");
            }

            // --- NEW: Basic Content Protection ---
            document.addEventListener('contextmenu', (e) => e.preventDefault()); // Disable right-click

            document.addEventListener('keydown', (e) => {
                // Disable F12
                if (e.key === 'F12') {
                    e.preventDefault();
                }
                // Disable Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
                if (e.ctrlKey && (e.shiftKey && (e.key === 'I' || e.key === 'J') || e.key === 'u')) {
                    e.preventDefault();
                }
            });

            // --- NEW: Background Preloader (Tier 2) ---
            function preloadBackgroundImages() {
                console.log("Starting background preload...");
                const gradFolders = [
                    // Design already fully loaded (count=2)
                    { folder: 'grad_model', count: 21, ext: 'webp' },
                    { folder: 'grad_proposal', count: 68, ext: 'webp' },
                    { folder: 'grad_book', count: 24, ext: 'webp' }
                ];

                const urls = [];
                gradFolders.forEach(info => {
                    // Start from 6, since 1-5 are already loaded
                    for (let i = 6; i <= info.count; i++) {
                        urls.push(`${info.folder}/${i}.${info.ext}`);
                    }
                });

                // Load sequentially or in small batches to avoid network congestion
                let loaded = 0;
                const total = urls.length;

                // Simple sequential loader
                const loadNext = () => {
                    if (!backgroundPreloadActive) {
                        console.log("Background preload stopped.");
                        return;
                    }
                    if (loaded >= total) {
                        console.log("Background preload complete.");
                        return;
                    }
                    const img = new Image();
                    img.src = urls[loaded];
                    img.onload = img.onerror = () => {
                        loaded++;
                        // Small delay to yield to main thread
                        setTimeout(loadNext, 50); // Increased delay to 50ms for better responsiveness
                    };
                };

                if (urls.length > 0) loadNext();
            }

            // Ensure body overflow is hidden during load
            document.body.style.overflow = 'hidden';
            window.addEventListener('load', () => {
                initLoader();
                // Delay preloading slightly after initial load to prioritize main assets
                setTimeout(preloadMenuImages, 2000);

                // Start background preload after 4 seconds (let initial animation finish)
                setTimeout(preloadBackgroundImages, 4000);

                initLightboxZoom(); // Initialize light box zoom/pan logic
            });
        </script>
</body>

</html>